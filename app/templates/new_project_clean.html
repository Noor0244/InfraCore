{% set fallback_project_types = ["Road", "Bridge", "Flyover", "Building", "Utility / Pipeline"] %}
{% set fallback_legacy_project_types = ["Residential", "Commercial", "Industrial", "Utility", "Other"] %}
{% set fallback_road_categories = ["Expressway", "National Highway (NH)", "State Highway (SH)", "Major District Road (MDR)", "Other District Road (ODR)", "Village / Rural Road (VR)", "Urban Road", "Service Road"] %}
{% set project_types = classification_metadata.get('project_types', []) %}
{% set legacy_project_types = classification_metadata.get('legacy_project_types', []) %}
{% set road_categories = classification_metadata.get('road_categories', []) %}
{% if not project_types %}{% set project_types = fallback_project_types %}{% endif %}
{% if not legacy_project_types %}{% set legacy_project_types = fallback_legacy_project_types %}{% endif %}
{% if not road_categories %}{% set road_categories = fallback_road_categories %}{% endif %}

<h1 class="page-title">Create New Project</h1>

<div class="help-text" style="margin:-6px 0 14px;opacity:0.9">
    Prefer a guided flow? <a href="/projects/wizard/start">Start the Project Wizard</a>
</div>

<div class="card card--page">

<style>
    /* Card and Section Styling */
    .card--page {
        background: var(--card-bg);
        border-radius: 18px;
        box-shadow: 0 4px 32px 0 rgba(0,0,0,0.18), 0 1.5px 6px 0 rgba(0,0,0,0.10);
        padding: 32px 32px 24px 32px;
        margin: 0 auto 32px auto;
        max-width: 1100px;
        color: var(--text-primary);
    }
    .form-section {
        margin-bottom: 32px;
        padding-bottom: 18px;
        border-bottom: 1px solid var(--border-color);
    }
    .section-title {
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 12px;
        letter-spacing: 0.01em;
    }
    .form-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 18px 24px;
        margin-bottom: 8px;
    }
    /* Inputs */
    input[type="text"], input[type="number"], input[type="email"], input[type="password"], select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1.5px solid var(--input-border);
        background: var(--input-bg);
        color: var(--text-primary);
        font-size: 1rem;
        margin-top: 4px;
        transition: border-color 0.18s, box-shadow 0.18s;
        box-shadow: 0 1.5px 4px 0 rgba(0,0,0,0.07);
    }
    input[type="text"]:focus, input[type="number"]:focus, input[type="email"]:focus, input[type="password"]:focus, select:focus {
        border-color: #2563eb;
        outline: none;
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.18);
    }
    label {
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 2px;
        display: block;
    }
    .help-text {
        color: var(--text-secondary);
        font-size: 0.97em;
        margin-top: 2px;
    }
    /* Buttons */
    button, .btn-primary, .btn-secondary, .btn-danger, .btn-small {
        position: relative;
        overflow: hidden;
        border: none;
        border-radius: 8px;
        padding: 10px 22px;
        font-size: 1rem;
        font-weight: 600;
        background: linear-gradient(90deg, #2563eb 60%, #1d4ed8 100%);
        color: #fff;
        cursor: pointer;
        box-shadow: 0 2px 8px 0 rgba(37, 99, 235, 0.10);
        transition: background 0.18s, box-shadow 0.18s, transform 0.12s;
        margin-right: 8px;
    }
    button:hover, .btn-primary:hover, .btn-secondary:hover, .btn-danger:hover, .btn-small:hover {
        background: linear-gradient(90deg, #1d4ed8 60%, #2563eb 100%);
        box-shadow: 0 4px 16px 0 rgba(37, 99, 235, 0.18);
        transform: translateY(-2px) scale(1.03);
    }
    .btn-secondary {
        background: #e5e7eb;
        color: #111827;
    }
    .btn-secondary:hover {
        background: #d1d5db;
    }
    .dark .btn-secondary {
        background: #374151;
        color: #e5e7eb;
    }
    .dark .btn-secondary:hover {
        background: #4b5563;
    }
    .btn-danger {
        background: linear-gradient(90deg, #ef4444 60%, #dc2626 100%);
        color: #fff;
    }
    .btn-danger:hover {
        background: linear-gradient(90deg, #dc2626 60%, #ef4444 100%);
    }
    .btn-small {
        font-size: 0.95em;
        padding: 7px 14px;
    }
    .required {
        color: #ffb347;
        font-size: 1.1em;
        margin-left: 2px;
    }
    .form-errors{
        display:none;margin:0 0 14px;padding:10px 12px;border:1px solid rgba(214,69,69,0.45);background:rgba(214,69,69,0.12);border-radius:8px;color:var(--text-primary)
    }
    .is-invalid{border-color: rgba(214,69,69,0.9) !important; box-shadow: 0 0 0 3px rgba(214,69,69,0.15)}
    .date-dual{display:flex;gap:8px;align-items:center}
    .date-dual input[type="date"]{max-width:170px}
    /* Ripple effect for all buttons */
    button, .btn-primary, .btn-secondary, .btn-danger, .btn-small {
        position: relative;
        overflow: hidden;
    }
    .ripple {
        position: absolute;
        border-radius: 50%;
        transform: scale(0);
        animation: ripple-animate 0.5s linear;
        background-color: rgba(255,255,255,0.4);
        pointer-events: none;
        z-index: 2;
    }
    @keyframes ripple-animate {
        to {
            transform: scale(2.5);
            opacity: 0;
        }
    }
    /* Table improvements */
    table.table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        background: var(--card-bg);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 12px;
        color: var(--text-primary);
    }
    table.table th, table.table td {
        padding: 10px 8px;
        text-align: left;
        color: var(--text-primary);
        border-bottom: 1px solid var(--border-color);
    }
    table.table th {
        background: rgba(0,0,0,0.03);
        font-weight: 700;
        font-size: 1.05em;
        letter-spacing: 0.01em;
        color: var(--text-secondary);
    }
    table.table tr:last-child td {
        border-bottom: none;
    }
    /* Responsive tweaks */
    @media (max-width: 900px) {
        .card--page { padding: 18px 4vw 12px 4vw; }
        .form-grid { grid-template-columns: 1fr; }
    }
</style>

<form id="createProjectForm" method="post" action="/projects/create">

    <div id="formErrors" class="form-errors"></div>

    <!-- ================= BASIC INFO ================= -->
    <section class="form-section">
        <h3 class="section-title">Basic Information</h3>

        <div class="form-grid">
            <div>
                <label>Project Name <span class="required">*</span></label>
                <input type="text" name="name" required>
                <div class="help-text">Use a concise, descriptive name (e.g. NH-66 Upgrade)</div>
            </div>

            <div>
                <label>Project Code / Package No</label>
                <input type="text" name="project_code">
            </div>

            <div>
                <label>Client / Authority</label>
                <input type="text" name="client_authority">
            </div>

            <div>
                <label>Contractor</label>
                <input type="text" name="contractor">
            </div>

            <div>
                <label>Consultant / PMC</label>
                <input type="text" name="consultant_pmc">
            </div>
        </div>
    </section>

    <hr>

    <!-- ================= ROLE BASED USER ================= -->
    {% if user and user["role"] in ["admin", "superadmin"] %}

    <section class="form-section" id="project_team_section">
        <h3 class="section-title">Role Based User</h3>
        <div class="help-text">Assign users to this project and set their role.</div>

        <div class="card" style="margin-bottom:14px;padding:12px">
            <h4 class="section-title" style="font-size:14px;margin:0 0 8px 0">Create User</h4>
            <div class="help-text" style="margin-bottom:10px">Create a system user (Admin/Manager/User/Viewer).</div>
            <div class="form-grid">
                <div>
                    <label>Username</label>
                    <input type="text" name="username" form="createUserForm" required autocomplete="off" spellcheck="false">
                </div>
                <div>
                    <label>Email</label>
                    <input type="email" name="email" form="createUserForm" autocomplete="off">
                </div>
                <div>
                    <label>Password</label>
                    <input type="password" name="password" form="createUserForm" required autocomplete="new-password">
                </div>
                <div>
                    <label>System Role</label>
                    <select name="role" form="createUserForm" required autocomplete="off">
                        <option value="admin">Admin</option>
                        <option value="manager">Manager</option>
                        <option value="user" selected>User</option>
                        <option value="viewer">Viewer</option>
                    </select>
                </div>
            </div>

            <div style="margin-top:10px">
                <button type="submit" class="btn-primary" form="createUserForm">Create User</button>
            </div>
        </div>

        <div class="form-grid">
            <div>
                <label>User</label>
                <select id="project_team_user">
                    <option value="">Select User</option>
                    {% for u in (all_users or []) %}
                        {% if u.role != "superadmin" %}
                        <option value="{{ u.id }}">{{ u.username }}</option>
                        {% endif %}
                    {% endfor %}
                </select>
            </div>

            <div>
                <label>Role in Project</label>
                <select id="project_team_role">
                    <option value="admin">Admin</option>
                    <option value="manager">Manager</option>
                    <option value="viewer" selected>Viewer</option>
                    <option value="member">Member</option>
                </select>
            </div>

            <div style="display:flex;align-items:flex-end">
                <button type="button" class="btn-primary" id="add_project_team">Add User</button>
            </div>
        </div>

        <div id="project_team_list" style="margin-top:12px"></div>
    </section>

    <hr>
    {% endif %}

    <!-- ================= PROJECT TIMELINE ================= -->
    <section class="form-section">
        <h3 class="section-title">Project Timeline</h3>

        <div class="form-grid">
            <div>
                <label>Project Start Date <span class="required">*</span></label>
                <!-- DD/MM/YYYY: Slashes auto-inserted, 4-digit year only -->
                <input type="text" name="planned_start_date" id="planned_start_date" required placeholder="DD/MM/YYYY" maxlength="10" inputmode="numeric" pattern="\d{1,2}/\d{1,2}/\d{4}">
                <div class="help-text">Pick from calendar. Format: <b>DD/MM/YYYY</b></div>
            </div>

            <div>
                <label>Project End Date <span class="required">*</span></label>
                <!-- DD/MM/YYYY: Slashes auto-inserted, 4-digit year only -->
                <input type="text" name="planned_end_date" id="planned_end_date" required placeholder="DD/MM/YYYY" maxlength="10" inputmode="numeric" pattern="\d{1,2}/\d{1,2}/\d{4}">
                <script>
                // Unified date formatter and validator for all date fields
                function attachDateFormatter(input, getMin, getMax) {
                    if (!input || input._dateFormatHandler) return;
                    function formatDate(val) {
                        let value = String(val || '').replace(/\D/g, '').slice(0, 8);
                        let formatted = '';
                        if (value.length > 0) formatted += value.substring(0, 2);
                        if (value.length > 2) formatted += '/' + value.substring(2, 4);
                        if (value.length > 4) formatted += '/' + value.substring(4, 8);
                        return formatted;
                    }
                    function isValidDdmmyyyy(str) {
                        if (!/^\d{2}\/\d{2}\/\d{4}$/.test(str)) return false;
                        const [d, m, y] = str.split('/').map(Number);
                        if (y < 1900 || y > 2100 || m < 1 || m > 12 || d < 1 || d > 31) return false;
                        const dt = new Date(y, m - 1, d);
                        return dt.getFullYear() === y && dt.getMonth() === m - 1 && dt.getDate() === d;
                    }
                    function enforceFormat(e) {
                        let formatted = formatDate(input.value);
                        input.value = formatted;
                        let warn = false, msg = '';
                        if (formatted.length === 10) {
                            if (!isValidDdmmyyyy(formatted)) {
                                warn = true;
                                msg = 'Invalid date format (DD/MM/YYYY required)';
                            } else {
                                let min = getMin && getMin();
                                let max = getMax && getMax();
                                let d = formatted.split('/');
                                let dt = new Date(+d[2], +d[1] - 1, +d[0]);
                                if (min && dt < min) {
                                    warn = true;
                                    msg = 'Date is before allowed minimum (' + min.toLocaleDateString('en-GB') + ')';
                                }
                                if (max && dt > max) {
                                    warn = true;
                                    msg = 'Date is after allowed maximum (' + max.toLocaleDateString('en-GB') + ')';
                                }
                            }
                        }
                        if (warn) {
                            input.style.borderColor = '#d44545';
                            input.style.background = 'rgba(214,69,69,0.18)';
                            input.title = msg;
                        } else {
                            input.style.borderColor = '';
                            input.style.background = '';
                            input.title = '';
                        }
                    }
                    input.addEventListener('input', enforceFormat);
                    input.addEventListener('blur', enforceFormat);
                    input.addEventListener('paste', function(e) {
                        e.preventDefault();
                        let paste = (e.clipboardData || window.clipboardData).getData('text');
                        input.value = formatDate(paste);
                        enforceFormat();
                    });
                    input.setAttribute('maxlength', '10');
                    input.setAttribute('pattern', '\\d{2}/\\d{2}/\\d{4}');
                    input.setAttribute('inputmode', 'numeric');
                    input.setAttribute('placeholder', 'DD/MM/YYYY');
                    input._dateFormatHandler = true;
                }
                // Attach to project start/end date fields
                attachDateFormatter(document.getElementById('planned_start_date'));
                attachDateFormatter(document.getElementById('planned_end_date'), function() {
                    // End date min = start date
                    let v = document.getElementById('planned_start_date').value;
                    if (/^\d{2}\/\d{2}\/\d{4}$/.test(v)) {
                        let d = v.split('/');
                        return new Date(+d[2], +d[1] - 1, +d[0]);
                    }
                    return null;
                });
                </script>
                <div class="help-text">End date must be after start date. Format: <b>DD/MM/YYYY</b></div>
            </div>
        </div>
    </section>

    <hr>

    <!-- ================= ROAD SETUP ================= -->
    <section class="form-section">
        <h3 class="section-title">Project Classification</h3>

        <div class="form-grid">
            <div style="min-width:260px">
                <label>Project Type <span class="required">*</span></label>
                <select name="project_type" id="project_type" required>
                    <option value="">-- Select project type --</option>
                    {% for pt in (project_types + legacy_project_types) %}
                        <option value="{{ pt }}">{{ pt }}</option>
                    {% endfor %}
                </select>
                <div class="help-text">Road projects must also fill Road Category and Road Engineering Type below.</div>
            </div>
        </div>

        <div class="form-grid" id="road_fields_block" style="margin-top:10px;display:none">
            <div style="min-width:260px">
                <label>Road Category (required only for Road)</label>
                <select name="road_category" id="road_category">
                    <option value="">-- Select road category --</option>
                    {% for rc in road_categories %}
                        <option value="{{ rc }}">{{ rc }}</option>
                    {% endfor %}
                </select>
            </div>

            <div style="min-width:260px">
                <label>Road Engineering Type (required only for Road)</label>
                <select name="road_engineering_type" id="road_engineering_type">
                    <option value="">-- Select engineering type --</option>
                    <option value="Flexible">Flexible</option>
                    <option value="Rigid">Rigid</option>
                    <option value="Overlay">Overlay</option>
                    <option value="Urban">Urban</option>
                    <option value="Rural">Rural</option>
                    <option value="Composite">Composite</option>
                </select>
            </div>
        </div>
    </section>

    <!-- ================= STRETCH SYSTEM (ROAD ONLY) ================= -->
    <section class="form-section" id="stretch_system_block" style="display:none">
        <h3 class="section-title">Stretch System (Road Projects)</h3>
        <div class="help-text">Mandatory for Road projects. Stretches remain editable after creation.</div>

        <input type="hidden" name="stretch_enabled" id="stretch_enabled" value="1">

        <div class="form-grid" style="margin-top:10px">
            <div>
                <label>Total Road Length (km) <span class="required">*</span></label>
                <input type="number" id="stretch_total_length_km" step="0.01" min="0" placeholder="e.g. 12.50" value="">
                <input type="hidden" name="road_length_km" id="road_length_km">
            </div>
            <div>
                <label>Total Number of Stretches <span class="required">*</span></label>
                <input type="number" id="stretch_number_of_stretches" min="1" step="1" value="">
            </div>
            <div style="display:flex;align-items:flex-end;gap:8px">
                <button type="button" class="btn-primary" id="btnGenerateStretches">Generate stretches</button>
                <button type="button" class="btn-secondary" id="btnAlignStretches" style="display:none">Align All Remaining Stretches</button>
            </div>
        </div>

        <input type="hidden" name="stretch_segments_json" id="stretch_segments_json">

        <div id="stretch_editor" style="margin-top:14px;display:none">
            <div class="help-text">Edit stretch length to update chainage. Total length must equal the road length.</div>

            <div style="overflow:auto;border:1px solid rgba(255,255,255,0.08);border-radius:12px;margin-top:10px">
                <table class="table" style="margin:0;min-width:920px">
                    <thead>
                        <tr>
                            <th style="width:80px">No</th>
                            <th style="width:220px">Stretch Name</th>
                            <th style="width:140px">Start Chainage</th>
                            <th style="width:140px">End Chainage</th>
                            <th style="width:120px">Length (m)</th>
                            <th style="width:100px">Width (m)</th>
                            <th style="width:100px">Depth (m)</th>
                            <th style="width:170px">Start Date</th>
                            <th style="width:170px">End Date</th>
                        </tr>
                    </thead>
                    <tbody id="stretchSegmentList"></tbody>
                </table>
            </div>

            <div id="stretchDetailsList" style="margin-top:12px"></div>
        </div>
        <div style="margin-top:16px">
            <h4 class="section-title" style="font-size:14px">Road Details (fill for Road projects)</h4>

        <div class="form-grid">
            <div>
                <label>Lane Configuration</label>
                <select name="lane_configuration" id="lane_configuration_select" onchange="document.getElementById('lane_configuration_custom').style.display = this.value === 'custom' ? '' : 'none';">
                    <option value="">-- Select --</option>
                    <option value="2L">2L</option>
                    <option value="4L">4L (2x2)</option>
                    <option value="6L">6L (3x3)</option>
                    <option value="custom">Custom</option>
                </select>
                <input type="text" name="lane_configuration" id="lane_configuration_custom" placeholder="e.g. 2x2, 8L divided" style="display:none;margin-top:6px;">
            </div>
            <div>
                <label>Road Width (m)</label>
                <input type="number" step="0.01" name="road_width">
            </div>
            <div>
                <label>Carriageway Width (m)</label>
                <input type="number" step="0.01" name="carriageway_width">
            </div>
            <div>
                <label>Shoulder Type</label>
                <input type="text" name="shoulder_type">
            </div>
            <div>
                <label>Median Type</label>
                <input type="text" name="median_type">
            </div>
        </div>

        <div style="margin-top:16px">
            <h4 class="section-title" style="font-size:14px">Road Metadata (optional)</h4>

        <div class="form-grid">
            <div>
                <label>Road Name</label>
                <input type="text" name="road_name">
            </div>


            <div>
                <label>Pavement Type</label>
                <select name="road_pavement_type">
                    <option value="">-- Select --</option>
                    <option value="Flexible">Flexible</option>
                    <option value="Rigid">Rigid</option>
                </select>
            </div>

            <div>
                <label>Terrain Type</label>
                <select name="terrain_type">
                    <option value="">-- Select --</option>
                    <option value="Plain">Plain</option>
                    <option value="Rolling">Rolling</option>
                    <option value="Hilly">Hilly</option>
                </select>
            </div>
        </div>
    </section>

    <hr>

    <!-- ================= CONCRETE DETAILS ================= -->
    <section class="form-section" id="concrete_details_block" style="display:none">
        <h3 class="section-title">Concrete Pavement Details (optional)</h3>

        <div class="form-grid">
            <div>
                <label>Concrete Pavement Type</label>
                <select name="pavement_type">
                    <option value="">-- Select --</option>
                    <option value="PQC">PQC</option>
                    <option value="RCC">RCC</option>
                </select>
            </div>

            <div>
                <label>Slab Thickness (mm)</label>
                <input type="number" name="slab_thickness_mm" min="100" step="1">
            </div>

            <div>
                <label>Grade of Concrete</label>
                <select name="grade_of_concrete">
                    <option value="">-- Select grade --</option>
                    <option value="M30">M30</option>
                    <option value="M35">M35</option>
                    <option value="M40">M40</option>
                </select>
            </div>

            <div>
                <label>Joint Spacing (m)</label>
                <input type="number" name="joint_spacing_m" min="3" step="0.1">
            </div>

            <div>
                <label>Dowel Diameter (mm)</label>
                <input type="number" name="dowel_diameter_mm" min="16" step="1">
            </div>

            <div>
                <label>Tie Bar Diameter (mm)</label>
                <input type="number" name="tie_bar_diameter_mm" min="12" step="1">
            </div>
        </div>
    </section>

    <hr>

    <!-- ================= LOCATION ================= -->
    <section class="form-section">
        <h3 class="section-title">Location</h3>

        <div class="form-grid">
            <div>
                <label>Country <span class="required">*</span></label>
                <input type="text" name="country" value="India" required>
            </div>

            <div>
                <label>State / Province</label>
                <input type="text" name="state">
            </div>

            <div>
                <label>District</label>
                <input type="text" name="district">
            </div>

            <div>
                <label>City <span class="required">*</span></label>
                <input type="text" name="city" required>
            </div>
        </div>

        <div class="form-grid" style="margin-top:12px">
            <div>
                <label>Start Chainage</label>
                <input type="text" name="chainage_start">
            </div>

            <div>
                <label>End Chainage</label>
                <input type="text" name="chainage_end">
            </div>
        </div>
    </section>

    <hr>

    <!-- ================= HIDDEN PAYLOADS ================= -->
    <input type="hidden" name="activity_presets_json">
    <input type="hidden" name="activity_preset_defs_json">
    <input type="hidden" name="material_presets_json">
    <input type="hidden" name="material_preset_defs_json">
    <input type="hidden" name="project_team_json">
    <input type="hidden" name="road_extras_json">

    <!-- ================= ACTIONS ================= -->
    <div style="display:flex;gap:12px;margin-top:20px">
        <button class="btn-primary" type="submit">Create Project</button>
        <a href="/dashboard" class="btn-secondary">Cancel</a>
    </div>

    <script>
    // Material-style ripple effect for all buttons
    document.addEventListener('DOMContentLoaded', function() {
        document.body.addEventListener('click', function(e) {
            const btn = e.target.closest('button');
            if (!btn) return;
            // Remove any old ripple
            let oldRipple = btn.querySelector('.ripple');
            if (oldRipple) oldRipple.remove();
            // Create ripple
            const ripple = document.createElement('span');
            ripple.className = 'ripple';
            const rect = btn.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = (e.clientX - rect.left - size/2) + 'px';
            ripple.style.top = (e.clientY - rect.top - size/2) + 'px';
            btn.appendChild(ripple);
            ripple.addEventListener('animationend', function() {
                ripple.remove();
            });
        }, false);
    });

    (function(){
        const allowAdminRole = JSON.parse('{{ (user and user["role"] in ["admin", "superadmin"]) | tojson }}');
        const projectType = document.querySelector('select[name="project_type"]');
        const roadCategory = document.querySelector('select[name="road_category"]');
        const roadEngineering = document.querySelector('select[name="road_engineering_type"]');
        const stretchBlock = document.getElementById('stretch_system_block');
        const roadFieldsBlock = document.getElementById('road_fields_block');
        const concreteBlock = document.getElementById('concrete_details_block');
        const stretchEnabled = document.getElementById('stretch_enabled');
        const totalLenKm = document.getElementById('stretch_total_length_km');
        const stretchCount = document.getElementById('stretch_number_of_stretches');
        const btnGenerate = document.getElementById('btnGenerateStretches');
        const btnAlign = document.getElementById('btnAlignStretches');
        const stretchEditor = document.getElementById('stretch_editor');
        const stretchList = document.getElementById('stretchSegmentList');
        const stretchDetails = document.getElementById('stretchDetailsList');
        const segmentsJson = document.getElementById('stretch_segments_json');
        const roadLengthKm = document.querySelector('input[name="road_length_km"]');

        const startText = document.getElementById('planned_start_date_text');
        const endText = document.getElementById('planned_end_date_text');
        const startPicker = document.getElementById('planned_start_date_picker');
        const endPicker = document.getElementById('planned_end_date_picker');

        const activityDefsInput = document.querySelector('input[name="activity_preset_defs_json"]');
        const materialDefsInput = document.querySelector('input[name="material_preset_defs_json"]');
        const createUserName = document.querySelector('input[name="username"][form="createUserForm"]');
        const createUserPass = document.querySelector('input[name="password"][form="createUserForm"]');
        const createUserEmail = document.querySelector('input[name="email"][form="createUserForm"]');
        const createUserRole = document.querySelector('select[name="role"][form="createUserForm"]');
        const teamInput = document.querySelector('input[name="project_team_json"]');

        const teamUserSelect = document.getElementById('project_team_user');
        const teamRoleSelect = document.getElementById('project_team_role');
        const teamList = document.getElementById('project_team_list');
        const teamAddBtn = document.getElementById('add_project_team');

        let presetData = { activities: [], activity_preset_defs: [], materials: [] };
        let segments = [];
        let teamMembers = [];

        function roleOptions(selected){
            const sel = String(selected || 'member').toLowerCase();
            let opts = '';
            const base = [
                { value: 'viewer', label: 'Viewer' },
                { value: 'manager', label: 'Manager' },
                { value: 'member', label: 'Member' },
            ];
            if(allowAdminRole){
                base.unshift({ value: 'admin', label: 'Admin' });
            }
            opts = base.map(function(r){
                const isSel = r.value === sel ? ' selected' : '';
                return '<option value="' + r.value + '"' + isSel + '>' + r.label + '</option>';
            }).join('');
            return opts;
        }

        function renderTeamList(){
            if(!teamList){
                return;
            }
            if(!teamMembers.length){
                teamList.innerHTML = '<div class="help-text">No users assigned yet.</div>';
            } else {
                const rows = teamMembers.map(function(m, idx){
                    const role = String(m.role_in_project || '').toUpperCase();
                    return (
                        '<tr>' +
                            '<td>' + String(m.username || 'User') + '</td>' +
                            '<td>' +
                                '<div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">' +
                                    '<span class="badge badge-info">' + role + '</span>' +
                                    '<select data-action="change-role" data-idx="' + idx + '">' + roleOptions(m.role_in_project) + '</select>' +
                                '</div>' +
                            '</td>' +
                            '<td><button type="button" class="btn-danger" data-action="remove-team" data-idx="' + idx + '">Remove</button></td>' +
                        '</tr>'
                    );
                }).join('');
                teamList.innerHTML = (
                    '<table class="table" style="margin:0">' +
                        '<thead><tr><th>User</th><th>Role</th><th>Action</th></tr></thead>' +
                        '<tbody>' + rows + '</tbody>' +
                    '</table>'
                );
            }
            if(teamInput){
                teamInput.value = JSON.stringify(teamMembers.map(function(m){
                    return { user_id: m.user_id, role_in_project: m.role_in_project };
                }));
            }
        }

        function addTeamMember(){
            if(!teamUserSelect || !teamRoleSelect){
                return;
            }
            const userId = parseInt(teamUserSelect.value || '0', 10);
            if(!userId){
                return;
            }
            const role = String(teamRoleSelect.value || 'member').toLowerCase();
            const username = teamUserSelect.options[teamUserSelect.selectedIndex].text || 'User';

            const existing = teamMembers.find(function(m){ return m.user_id === userId; });
            if(existing){
                existing.role_in_project = role;
                existing.username = username;
            } else {
                teamMembers.push({ user_id: userId, role_in_project: role, username: username });
            }
            renderTeamList();
        }

        function ddmmyyyyToIso(v){
            const s = String(v || '').trim();
            if(!s) return '';
            const parts = s.split('/');
            if(parts.length !== 3) return '';
            const [dd, mm, yyyy] = parts;
            if(!dd || !mm || !yyyy) return '';
            return `${yyyy}-${mm.padStart(2,'0')}-${dd.padStart(2,'0')}`;
        }

        function isoToDdmmyyyy(v){
            const s = String(v || '').trim();
            if(!s) return '';
            const parts = s.split('-');
            if(parts.length !== 3) return '';
            const [yyyy, mm, dd] = parts;
            return `${dd.padStart(2,'0')}/${mm.padStart(2,'0')}/${yyyy}`;
        }

        function chainageFromMeters(m){
            const km = Math.floor(m / 1000);
            const mm = String(m % 1000).padStart(3, '0');
            return `${km}+${mm}`;
        }

        function ddmmyyyyToDate(str) {
            if (!str) return null;
            const parts = String(str || '').split('/');
            if (parts.length !== 3) return null;
            const [dd, mm, yyyy] = parts;
            return new Date(parseInt(yyyy, 10), parseInt(mm, 10) - 1, parseInt(dd, 10));
        }

        function dateToDdmmyyyy(date) {
            if (!date) return '';
            const d = date.getDate().toString().padStart(2, '0');
            const m = (date.getMonth() + 1).toString().padStart(2, '0');
            const y = date.getFullYear();
            return `${d}/${m}/${y}`;
        }

        function isRoad(){
            return projectType && projectType.value === 'Road';
        }

        function toggleRoadFields(){
            if(!roadFieldsBlock) return;
            if(isRoad()){
                roadFieldsBlock.style.display = '';
                if(roadCategory) roadCategory.required = true;
                if(roadEngineering) roadEngineering.required = true;
            } else {
                roadFieldsBlock.style.display = 'none';
                if(roadCategory){
                    roadCategory.required = false;
                    roadCategory.value = '';
                }
                if(roadEngineering){
                    roadEngineering.required = false;
                    roadEngineering.value = '';
                }
                if(concreteBlock){
                    concreteBlock.style.display = 'none';
                }
            }
        }

        function toggleConcreteBlock(){
            if(!concreteBlock) return;
            const et = roadEngineering ? String(roadEngineering.value || '').trim() : '';
            if(isRoad() && et === 'Rigid'){
                concreteBlock.style.display = '';
            } else {
                concreteBlock.style.display = 'none';
            }
        }

        function syncTimelineInputs(){
            if(startPicker && startText){
                startPicker.value = ddmmyyyyToIso(startText.value);
            }
            if(endPicker && endText){
                endPicker.value = ddmmyyyyToIso(endText.value);
            }
        }

        if(startPicker && startText){
            startPicker.addEventListener('change', function(){
                startText.value = isoToDdmmyyyy(startPicker.value);
                updateStretchDatesFromProject();
            });
        }
        if(endPicker && endText){
            endPicker.addEventListener('change', function(){
                endText.value = isoToDdmmyyyy(endPicker.value);
                updateStretchDatesFromProject();
            });
        }
        if(startText){
            startText.addEventListener('change', syncTimelineInputs);
        }
        if(endText){
            endText.addEventListener('change', syncTimelineInputs);
        }

        if(teamAddBtn){
            teamAddBtn.addEventListener('click', addTeamMember);
        }

        if(teamList){
            teamList.addEventListener('click', function(e){
                const target = e.target;
                if(!target || !target.getAttribute){
                    return;
                }
                if(target.getAttribute('data-action') === 'remove-team'){
                    const idx = parseInt(target.getAttribute('data-idx') || '-1', 10);
                    if(idx >= 0){
                        teamMembers.splice(idx, 1);
                        renderTeamList();
                    }
                }
            });

            teamList.addEventListener('change', function(e){
                const target = e.target;
                if(!target || !target.getAttribute){
                    return;
                }
                if(target.getAttribute('data-action') === 'change-role'){
                    const idx = parseInt(target.getAttribute('data-idx') || '-1', 10);
                    const role = String(target.value || 'member').toLowerCase();
                    if(idx >= 0 && teamMembers[idx]){
                        teamMembers[idx].role_in_project = role;
                        renderTeamList();
                    }
                }
            });
        }

        renderTeamList();

        if(createUserName) createUserName.value = '';
        if(createUserPass) createUserPass.value = '';
        if(createUserEmail) createUserEmail.value = '';
        if(createUserRole) createUserRole.value = 'user';

        function showStretchBlock(){
            if(!stretchBlock) return;
            if(isRoad()){
                stretchBlock.style.display = '';
                if(stretchEnabled) stretchEnabled.value = '1';
            } else {
                stretchBlock.style.display = 'none';
                if(stretchEnabled) stretchEnabled.value = '';
                segments = [];
                renderSegments();
            }
        }

        function syncTotalLength(){
            if(roadLengthKm && totalLenKm){
                roadLengthKm.value = String(totalLenKm.value || '').trim();
            }
        }

        async function loadRoadPresets(){
            if(!isRoad()) return;
            const rc = (roadCategory && roadCategory.value) ? roadCategory.value : '';
            const et = (roadEngineering && roadEngineering.value) ? roadEngineering.value : '';
            if(!rc || !et) return;
            try{
                const url = `/projects/road-presets?road_category=${encodeURIComponent(rc)}&engineering_type=${encodeURIComponent(et)}`;
                const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
                const data = await resp.json();
                if(data){
                    presetData.activities = Array.isArray(data.activities) ? data.activities : [];
                    presetData.activity_preset_defs = Array.isArray(data.activity_preset_defs) ? data.activity_preset_defs : [];
                    presetData.materials = Array.isArray(data.materials) ? data.materials : [];
                    if(activityDefsInput){
                        activityDefsInput.value = JSON.stringify(presetData.activity_preset_defs || []);
                    }
                    if(materialDefsInput){
                        materialDefsInput.value = JSON.stringify(presetData.materials || []);
                    }
                    if(segments && segments.length){
                        // Refresh activity/material lists after preset load
                        segments = segments.map(s => ({
                            ...s,
                            _showDetails: s._showDetails === true,
                            activities: baseActivities(),
                            materials: baseMaterials(),
                        }));
                        renderSegments();
                    }
                }
            }catch(e){
                presetData = { activities: [], activity_preset_defs: [], materials: [] };
            }
        }

        function baseActivities(){
            const defs = Array.isArray(presetData.activity_preset_defs) ? presetData.activity_preset_defs : [];
            if(defs.length){
                return defs
                    .filter(d => String(d.activity_scope || d.scope || '').toUpperCase() !== 'COMMON')
                    .map(d => ({
                        name: String(d.name || '').trim(),
                        include: true,
                        planned_start_date: startText ? String(startText.value || '').trim() : '',
                        planned_end_date: endText ? String(endText.value || '').trim() : '',
                        start_time: String(d.start_time || '').trim(),
                        end_time: String(d.end_time || '').trim(),
                        planned_duration_hours: null,
                    }))
                    .filter(a => !!a.name);
            }
            return (Array.isArray(presetData.activities) ? presetData.activities : [])
                .map(n => ({
                    name: String(n || '').trim(),
                    include: true,
                    planned_start_date: startText ? String(startText.value || '').trim() : '',
                    planned_end_date: endText ? String(endText.value || '').trim() : '',
                    start_time: '',
                    end_time: '',
                    planned_duration_hours: null,
                }))
                .filter(a => !!a.name);
        }

        function baseMaterials(){
            return (Array.isArray(presetData.materials) ? presetData.materials : [])
                .map(m => ({
                    name: String(m.name || '').trim(),
                    unit: String(m.default_unit || m.unit || 'unit').trim() || 'unit',
                    include: true,
                    quantity: '',
                }))
                .filter(m => !!m.name);
        }

        function updateStretchDatesFromProject(){
            segments.forEach(seg => {
                if(!seg._manual_start){
                    seg.planned_start_date = startText ? String(startText.value || '').trim() : '';
                }
                if(!seg._manual_end){
                    seg.planned_end_date = endText ? String(endText.value || '').trim() : '';
                }
                syncActivitiesToStretch(seg, true);
            });
            renderSegments();
        }

        function syncActivitiesToStretch(seg, forceAll){
            if(!seg) return;
            const sStart = String(seg.planned_start_date || '').trim();
            const sEnd = String(seg.planned_end_date || '').trim();
            (seg.activities || []).forEach(a => {
                if(forceAll || !a.planned_start_date) a.planned_start_date = sStart;
                if(forceAll || !a.planned_end_date) a.planned_end_date = sEnd;

                // Clamp activity dates to stretch window if both are set
                if(sStart && a.planned_start_date && a.planned_start_date < sStart){
                    a.planned_start_date = sStart;
                }
                if(sEnd && a.planned_end_date && a.planned_end_date > sEnd){
                    a.planned_end_date = sEnd;
                }
                // Ensure start <= end
                if(a.planned_start_date && a.planned_end_date && a.planned_start_date > a.planned_end_date){
                    a.planned_end_date = a.planned_start_date;
                }
            });
        }

        function computeHours(a){
            const sd = ddmmyyyyToIso(a.planned_start_date || '');
            const ed = ddmmyyyyToIso(a.planned_end_date || '');
            if(!sd || !ed) return null;
            const st = a.start_time || '00:00';
            const et = a.end_time || '00:00';
            const start = new Date(`${sd}T${st}:00`);
            const end = new Date(`${ed}T${et}:00`);
            if(isNaN(start.getTime()) || isNaN(end.getTime())) return null;
            const diff = (end.getTime() - start.getTime()) / 3600000;
            return diff >= 0 ? Math.round(diff * 100) / 100 : null;
        }

        function normalizeSegmentsTotal(){
            if(!segments.length || !totalLenKm) return;
            const totalKm = parseFloat(String(totalLenKm.value || '0')) || 0;
            if(totalKm <= 0) return;
            const totalM = Math.round(totalKm * 1000);

            segments.forEach(s => {
                const len = parseInt(String(s.length_m || '0'), 10) || 1;
                s.length_m = Math.max(1, len);
            });

            const lastIdx = segments.length - 1;
            const sumAll = segments.reduce((acc, s) => acc + (parseInt(String(s.length_m || '0'), 10) || 0), 0);
            if(sumAll !== totalM){
                const sumExceptLast = sumAll - segments[lastIdx].length_m;
                let newLast = totalM - sumExceptLast;
                if(newLast < 1){
                    // Enforce at least 1m per stretch
                    segments.forEach((s, idx) => { s.length_m = (idx === lastIdx ? 1 : 1); });
                    newLast = Math.max(1, totalM - (segments.length - 1));
                    segments[lastIdx].length_m = newLast;
                } else {
                    segments[lastIdx].length_m = newLast;
                }
            }

            let cursor = 0;
            segments.forEach(s => {
                s.start_m = cursor;
                s.end_m = cursor + s.length_m;
                cursor = s.end_m;
            });
        }

        function refreshStretchChainageUI(){
            if(!stretchList) return;
            const active = document.activeElement;
            segments.forEach((seg, idx) => {
                const startEl = stretchList.querySelector(`[data-kind="chainage-start"][data-idx="${idx}"]`);
                const endEl = stretchList.querySelector(`[data-kind="chainage-end"][data-idx="${idx}"]`);
                if(startEl) startEl.textContent = chainageFromMeters(seg.start_m);
                if(endEl) endEl.textContent = chainageFromMeters(seg.end_m);

                const lenInput = stretchList.querySelector(`input[data-kind="stretch-length"][data-idx="${idx}"]`);
                if(lenInput && lenInput !== active){
                    lenInput.value = String(seg.length_m);
                }
            });
        }

        function generateSegments(){
            const totalKm = parseFloat(String(totalLenKm && totalLenKm.value || '0')) || 0;
            const count = parseInt(String(stretchCount && stretchCount.value || '0'), 10) || 0;
            if(totalKm <= 0 || count <= 0) return;
            const totalM = Math.round(totalKm * 1000);
            const base = Math.floor(totalM / count);
            let cursor = 0;
            segments = [];
            for(let i=1;i<=count;i++){
                const isLast = i === count;
                const end = isLast ? totalM : (cursor + base);
                segments.push({
                    sequence_no: i,
                    stretch_code: `ST-${String(i).padStart(3,'0')}`,
                    stretch_name: `Stretch ${i}`,
                    start_m: cursor,
                    end_m: end,
                    length_m: Math.max(end - cursor, 1),
                    width_m: null,
                    depth_m: null,
                    planned_start_date: '', // Always empty for generated stretches
                    planned_end_date: '',   // Always empty for generated stretches
                    _manual_start: false,
                    _manual_end: false,
                    _showDetails: false,
                    activities: baseActivities(),
                });
                cursor = end;
            }
        }

        function serializeSegments(){
            if(!segmentsJson) return;
            const payload = segments.map(seg => ({
                sequence_no: seg.sequence_no,
                stretch_code: seg.stretch_code,
                stretch_name: seg.stretch_name,
                start_m: seg.start_m,
                end_m: seg.end_m,
                length_m: seg.length_m,
                width_m: seg.width_m || null,
                depth_m: seg.depth_m || null,
                planned_start_date: seg.planned_start_date,
                planned_end_date: seg.planned_end_date,
                activities: (seg.activities || []).map(a => ({
                    name: a.name,
                    include: !!a.include,
                    planned_start_date: a.planned_start_date,
                    planned_end_date: a.planned_end_date,
                    start_time: a.start_time || null,
                    end_time: a.end_time || null,
                    planned_duration_hours: a.planned_duration_hours,
                })),
                // materials removed as per request
            }));
            segmentsJson.value = JSON.stringify(payload);
        }

        function syncStretchDatesFromDom(){
            if(!stretchList || !segments.length) return;
            const startInputs = stretchList.querySelectorAll('input[data-kind="stretch-start"]');
            startInputs.forEach(function(input){
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                if(idx < 0 || idx >= segments.length) return;
                const val = String(input.value || '').trim();
                if(val){
                    segments[idx].planned_start_date = val;
                    segments[idx]._manual_start = true;
                }
            });
            const endInputs = stretchList.querySelectorAll('input[data-kind="stretch-end"]');
            endInputs.forEach(function(input){
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                if(idx < 0 || idx >= segments.length) return;
                const val = String(input.value || '').trim();
                if(val){
                    segments[idx].planned_end_date = val;
                    segments[idx]._manual_end = true;
                }
            });
            const startPickers = stretchList.querySelectorAll('input[data-kind="stretch-start-picker"]');
            startPickers.forEach(function(input){
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                if(idx < 0 || idx >= segments.length) return;
                const iso = String(input.value || '').trim();
                if(iso){
                    const dd = isoToDdmmyyyy(iso);
                    if(dd){
                        segments[idx].planned_start_date = dd;
                        segments[idx]._manual_start = true;
                    }
                }
            });
            const endPickers = stretchList.querySelectorAll('input[data-kind="stretch-end-picker"]');
            endPickers.forEach(function(input){
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                if(idx < 0 || idx >= segments.length) return;
                const iso = String(input.value || '').trim();
                if(iso){
                    const dd = isoToDdmmyyyy(iso);
                    if(dd){
                        segments[idx].planned_end_date = dd;
                        segments[idx]._manual_end = true;
                    }
                }
            });
        }

        function renderSegments(){
            if(!stretchEditor || !stretchList || !stretchDetails) return;
            stretchList.innerHTML = '';
            stretchDetails.innerHTML = '';
            if(!segments.length){
                stretchEditor.style.display = 'none';
                serializeSegments();
                if(btnAlign) btnAlign.style.display = 'none';
                return;
            }
            stretchEditor.style.display = '';

            // Show align button if more than 1 stretch
            if(btnAlign) btnAlign.style.display = segments.length > 1 ? '' : 'none';


            segments.forEach((seg, idx) => {
                // Clean up placeholder-like values so the placeholder shows
                let startVal = (seg.planned_start_date || '').trim();
                let endVal = (seg.planned_end_date || '').trim();
                // Matches dd-mm-yyyy, dd/mm/yyyy, d-m-yyyy, d/m/yyyy, etc. (case-insensitive)
                const isPlaceholder = v => {
                    if (!v) return true;
                    const cleaned = v.toLowerCase().replace(/\s/g, '');
                    return (
                        cleaned === 'dd-mm-yyyy' ||
                        cleaned === 'dd/mm/yyyy' ||
                        cleaned === 'd-m-yyyy' ||
                        cleaned === 'd/m/yyyy' ||
                        cleaned === 'ddmmyyyy' ||
                        cleaned === 'dmyyyy' ||
                        /^d{1,2}[-\/]?m{1,2}[-\/]?y{2,4}$/.test(cleaned)
                    );
                };
                if (isPlaceholder(startVal)) startVal = '';
                if (isPlaceholder(endVal)) endVal = '';
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><strong>${seg.sequence_no}</strong></td>
                    <td><input type="text" value="${seg.stretch_name}" data-kind="stretch-name" data-idx="${idx}" style="width:100%"></td>
                    <td><input type="text" value="${chainageFromMeters(seg.start_m)}" data-kind="chainage-start" data-idx="${idx}" style="width:100%" pattern="\\d+\\+\\d{3}" title="Format: km+mmm (e.g. 5+000)"></td>
                    <td><input type="text" value="${chainageFromMeters(seg.end_m)}" data-kind="chainage-end" data-idx="${idx}" style="width:100%" pattern="\\d+\\+\\d{3}" title="Format: km+mmm (e.g. 5+000)"></td>
                    <td><input type="number" min="1" step="1" value="${seg.length_m}" data-kind="stretch-length" data-idx="${idx}" style="width:100%"></td>
                    <td><input type="number" min="0" step="0.01" value="${seg.width_m || ''}" data-kind="stretch-width" data-idx="${idx}" style="width:100%"></td>
                    <td><input type="number" min="0" step="0.01" value="${seg.depth_m || ''}" data-kind="stretch-depth" data-idx="${idx}" style="width:100%"></td>
                    <td>
                        <div class="date-dual">
                            <input type="text" value="${startVal}" maxlength="10" inputmode="numeric" data-kind="stretch-start" data-idx="${idx}">
                        </div>
                    </td>
                    <td>
                        <div class="date-dual">
                            <input type="text" value="${endVal}" maxlength="10" inputmode="numeric" data-kind="stretch-end" data-idx="${idx}">
                        </div>
                    </td>
                `;
                // Force placeholder after element creation
                setTimeout(() => {
                    // Unified robust date formatter/validator for stretch dates
                    function attachDateFormatter(input, getMin, getMax) {
                        if (!input || input._dateFormatHandler) return;
                        function formatDate(val) {
                            let value = String(val || '').replace(/\D/g, '').slice(0, 8);
                            let formatted = '';
                            if (value.length > 0) formatted += value.substring(0, 2);
                            if (value.length > 2) formatted += '/' + value.substring(2, 4);
                            if (value.length > 4) formatted += '/' + value.substring(4, 8);
                            return formatted;
                        }
                        function isValidDdmmyyyy(str) {
                            if (!/^\d{2}\/\d{2}\/\d{4}$/.test(str)) return false;
                            const [d, m, y] = str.split('/').map(Number);
                            if (y < 1900 || y > 2100 || m < 1 || m > 12 || d < 1 || d > 31) return false;
                            const dt = new Date(y, m - 1, d);
                            return dt.getFullYear() === y && dt.getMonth() === m - 1 && dt.getDate() === d;
                        }
                        function enforceFormat(e) {
                            let formatted = formatDate(input.value);
                            input.value = formatted;
                            let warn = false, msg = '';
                            if (formatted.length === 10) {
                                if (!isValidDdmmyyyy(formatted)) {
                                    warn = true;
                                    msg = 'Invalid date format (DD/MM/YYYY required)';
                                } else {
                                    let min = getMin && getMin();
                                    let max = getMax && getMax();
                                    let d = formatted.split('/');
                                    let dt = new Date(+d[2], +d[1] - 1, +d[0]);
                                    if (min && dt < min) {
                                        warn = true;
                                        msg = 'Date is before allowed minimum (' + min.toLocaleDateString('en-GB') + ')';
                                    }
                                    if (max && dt > max) {
                                        warn = true;
                                        msg = 'Date is after allowed maximum (' + max.toLocaleDateString('en-GB') + ')';
                                    }
                                }
                            }
                            if (warn) {
                                input.style.borderColor = '#d44545';
                                input.style.background = 'rgba(214,69,69,0.18)';
                                input.title = msg;
                            } else {
                                input.style.borderColor = '';
                                input.style.background = '';
                                input.title = '';
                            }
                        }
                        input.addEventListener('input', enforceFormat);
                        input.addEventListener('blur', enforceFormat);
                        input.addEventListener('paste', function(e) {
                            e.preventDefault();
                            let paste = (e.clipboardData || window.clipboardData).getData('text');
                            input.value = formatDate(paste);
                            enforceFormat();
                        });
                        input.setAttribute('maxlength', '10');
                        input.setAttribute('pattern', '\\d{2}/\\d{2}/\\d{4}');
                        input.setAttribute('inputmode', 'numeric');
                        input.setAttribute('placeholder', 'DD/MM/YYYY');
                        input._dateFormatHandler = true;
                    }
                    attachDateFormatter(tr.querySelector('input[data-kind="stretch-start"]'));
                    attachDateFormatter(tr.querySelector('input[data-kind="stretch-end"]'), function() {
                        // End date min = start date
                        let v = tr.querySelector('input[data-kind="stretch-start"]').value;
                        if (/^\d{2}\/\d{2}\/\d{4}$/.test(v)) {
                            let d = v.split('/');
                            return new Date(+d[2], +d[1] - 1, +d[0]);
                        }
                        return null;
                    });
                }, 0);
                stretchList.appendChild(tr);

                const detail = document.createElement('div');
                detail.style.marginTop = '12px';
                detail.style.border = '1px solid rgba(255,255,255,0.08)';
                detail.style.borderRadius = '10px';
                detail.style.padding = '10px 12px';
                const showDetails = (seg._showDetails === true);
                detail.innerHTML = `
                    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:6px">
                        <div style="font-weight:600">${seg.stretch_name}</div>
                        <button type="button" class="btn-secondary btn-small" data-kind="toggle-details" data-idx="${idx}">
                            ${showDetails ? 'Hide' : 'Show'}
                        </button>
                    </div>
                    <div class="help-text" style="margin-top:-4px">Activities and materials for this stretch.</div>
                    <div data-kind="details-body" data-idx="${idx}" style="display:${showDetails ? '' : 'none'}">
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px">
                            <div>
                                <div style="font-weight:600">Activities</div>
                                <div class="help-text">Start/End dates must be within stretch dates.</div>
                                <div style="margin:6px 0; display: flex; gap: 8px; align-items: center;">
                                    <button type="button" class="btn-secondary btn-small" data-kind="act-add" data-idx="${idx}">+ Add Activity</button>
                                    <button type="button" class="btn-secondary btn-small" data-kind="update-days" data-idx="${idx}">Update Days</button>
                                </div>
                                <div data-kind="act-list" data-idx="${idx}"></div>
                            </div>
                            <!-- Material section removed as per request -->
                        </div>
                    </div>
                `;
                stretchDetails.appendChild(detail);

                const actList = detail.querySelector('[data-kind="act-list"]');
                if(!showDetails){
                    return;
                }
                // Apply time to all activities UI removed as per request
                // Auto-assign activity dates based on stretch start/end and number of activities
                const sStart = seg.planned_start_date;
                const sEnd = seg.planned_end_date;
                let actCount = (seg.activities || []).length;
                let startDate = ddmmyyyyToDate(sStart);
                let endDate = ddmmyyyyToDate(sEnd);
                if (startDate && endDate && actCount > 0) {
                    let totalDays = Math.max(1, Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1);
                    let daysPerAct = Math.floor(totalDays / actCount);
                    let remainder = totalDays % actCount;
                    let current = new Date(startDate);
                    (seg.activities || []).forEach((a, aidx) => {
                        // Robustly sanitize all system-generated activities
                        let s = ddmmyyyyToDate(a.planned_start_date);
                        let e = ddmmyyyyToDate(a.planned_end_date);
                        const hasStretchWindow = !!startDate && !!endDate;
                        // Only auto-correct when NOT manual and dates are missing/invalid
                        if (!a._manual_dates && hasStretchWindow && (!s || !e)) {
                            let actDays = daysPerAct + (aidx < remainder ? 1 : 0);
                            let actStart = new Date(current);
                            let actEnd = new Date(current);
                            actEnd.setDate(actEnd.getDate() + actDays - 1);
                            // Clamp to stretch range
                            if (actStart < startDate) actStart = new Date(startDate);
                            if (actEnd > endDate) actEnd = new Date(endDate);
                            a.planned_start_date = dateToDdmmyyyy(actStart);
                            a.planned_end_date = dateToDdmmyyyy(actEnd);
                            current.setDate(current.getDate() + actDays);
                            a._manual_dates = false;
                        } else if (a._manual_dates && hasStretchWindow) {
                            // For user-edited, clamp only if out of bounds
                            if (s && s < startDate) a.planned_start_date = dateToDdmmyyyy(startDate);
                            if (e && e > endDate) a.planned_end_date = dateToDdmmyyyy(endDate);
                        }
                    });
                }
                (seg.activities || []).forEach((a, aidx) => {
                    // Robustly sanitize activity start/end dates: if not valid, forcibly set to stretch start/end
                    function isValidDdmmyyyy(str) {
                        return /^\d{2}\/\d{2}\/\d{4}$/.test(str) && ddmmyyyyToDate(str) instanceof Date && !isNaN(ddmmyyyyToDate(str));
                    }
                    // If start/end date is invalid, only auto-fix for non-manual activities
                    if (!isValidDdmmyyyy(a.planned_start_date) && !a._manual_dates) {
                        a.planned_start_date = dateToDdmmyyyy(startDate);
                    }
                    if (!isValidDdmmyyyy(a.planned_end_date) && !a._manual_dates) {
                        a.planned_end_date = dateToDdmmyyyy(endDate);
                    }
                    const row = document.createElement('div');
                    row.style.display = 'grid';
                    row.style.gridTemplateColumns = 'minmax(180px,1fr) 130px 130px 80px 70px';
                    row.style.gap = '8px';
                    row.style.marginTop = '8px';
                    // Calculate days (inclusive)
                    let days = '';
                    let d1 = ddmmyyyyToDate(a.planned_start_date);
                    let d2 = ddmmyyyyToDate(a.planned_end_date);
                    if (d1 && d2) {
                        days = Math.max(1, Math.floor((d2 - d1) / (1000 * 60 * 60 * 24)) + 1);
                    }
                    row.innerHTML = `
                        <input type="text" value="${a.name}" data-kind="act-name" data-idx="${idx}" data-aidx="${aidx}">
                        <input type="text" value="${a.planned_start_date || ''}" placeholder="DD/MM/YYYY" maxlength="10" inputmode="numeric" pattern="\\d{1,2}/\\d{1,2}/\\d{4}" data-kind="act-start-date" data-idx="${idx}" data-aidx="${aidx}">
                        <input type="text" value="${a.planned_end_date || ''}" placeholder="DD/MM/YYYY" maxlength="10" inputmode="numeric" pattern="\\d{1,2}/\\d{1,2}/\\d{4}" data-kind="act-end-date" data-idx="${idx}" data-aidx="${aidx}">
                        <input type="text" value="${days}" readonly tabindex="-1" style="background:#222;color:#fff;opacity:0.8;width:48px;text-align:center;font-weight:600;border:1px solid #444;border-radius:6px;" title="Total days (auto-calculated)" data-kind="act-days" data-idx="${idx}" data-aidx="${aidx}">
                        <button type="button" class="btn-secondary btn-small" data-kind="act-remove" data-idx="${idx}" data-aidx="${aidx}">Remove</button>
                    `;
                    actList.appendChild(row);
                    // Attach date formatter to activity date fields
                    const actStartInput = row.querySelector('input[data-kind="act-start-date"]');
                    const actEndInput = row.querySelector('input[data-kind="act-end-date"]');
                    if (typeof attachDateFormatter === 'function') {
                        attachDateFormatter(actStartInput);
                        attachDateFormatter(actEndInput);
                    }
                });

                // Material list rendering removed as per request
            });

            serializeSegments();
            // Ensure days box updates after manual change
            updateActivityDays && updateActivityDays();
        }
        // After rendering, directly attach the formatter to each date input and force placeholder
        function attachDateFormatter(input) {
            if (!input || input._dateFormatHandler) return;
            function formatDate(val) {
                let value = val.replace(/\D/g, '').slice(0, 8);
                let formatted = '';
                if (value.length > 0) {
                    formatted += value.substring(0, 2);
                }
                if (value.length > 2) {
                    formatted += '/' + value.substring(2, 4);
                }
                if (value.length > 4) {
                    formatted += '/' + value.substring(4, 8);
                }
                return formatted;
            }
            function enforceFormat(e) {
                let formatted = formatDate(input.value);
                // Only clear if user entered 10 digits and it's not a valid date
                if (formatted.length === 10) {
                    const parts = formatted.split('/');
                    const d = parseInt(parts[0], 10);
                    const m = parseInt(parts[1], 10);
                    const y = parseInt(parts[2], 10);
                    const isValid = d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 1900 && y <= 2100;
                    if (!isValid) {
                        // Only clear if all 10 digits are present and invalid
                        input.value = formatted;
                        input.style.borderColor = '#d44545';
                        input.style.background = 'rgba(214,69,69,0.18)';
                        input.title = 'Invalid date format (DD/MM/YYYY required)';
                        return;
                    } else {
                        input.style.borderColor = '';
                        input.style.background = '';
                        input.title = '';
                    }
                } else {
                    input.style.borderColor = '';
                    input.style.background = '';
                    input.title = '';
                }
                input.value = formatted;
                // Move caret to end for better UX
                if (document.activeElement === input) {
                    input.setSelectionRange(formatted.length, formatted.length);
                }
            }
            input.addEventListener('input', enforceFormat);
            input.addEventListener('blur', enforceFormat);
            input.addEventListener('paste', function(e) {
                e.preventDefault();
                let paste = (e.clipboardData || window.clipboardData).getData('text');
                input.value = formatDate(paste);
                enforceFormat();
            });
            input.setAttribute('maxlength', '10');
            input.setAttribute('pattern', '\\d{2}/\\d{2}/\\d{4}');
            input.setAttribute('inputmode', 'numeric');
            input.setAttribute('placeholder', 'DD/MM/YYYY');
            input._dateFormatHandler = true;
        }
        var dateInputs = stretchList.querySelectorAll('input[data-kind="stretch-start"], input[data-kind="stretch-end"]');
        dateInputs.forEach(attachDateFormatter);
        var actDateInputs = stretchDetails.querySelectorAll('input[data-kind="act-start-date"], input[data-kind="act-end-date"]');
        // Update days fields when dates change (inclusive, always at least 1 if valid)
        function syncStretchDatesFromTableToSegments(){
            if(!stretchList || !segments.length) return;
            const startInputs = stretchList.querySelectorAll('input[data-kind="stretch-start"]');
            const endInputs = stretchList.querySelectorAll('input[data-kind="stretch-end"]');
            startInputs.forEach(function(input){
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                if(idx >= 0 && idx < segments.length){
                    segments[idx].planned_start_date = String(input.value || '').trim();
                }
            });
            endInputs.forEach(function(input){
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                if(idx >= 0 && idx < segments.length){
                    segments[idx].planned_end_date = String(input.value || '').trim();
                }
            });
        }
        function updateActivityDays() {
            var rows = stretchDetails.querySelectorAll('div[data-kind="act-list"] > div');
            rows.forEach(function(row) {
                var startInput = row.querySelector('input[data-kind="act-start-date"]');
                var endInput = row.querySelector('input[data-kind="act-end-date"]');
                var daysInput = row.querySelector('input[data-kind="act-days"]');
                if (startInput && endInput && daysInput) {
                    let d1 = ddmmyyyyToDate(startInput.value);
                    let d2 = ddmmyyyyToDate(endInput.value);
                    let days = '';
                    if (d1 && d2) {
                        // Always inclusive, and only if end >= start
                        let diff = Math.floor((d2 - d1) / (1000 * 60 * 60 * 24));
                        days = (diff >= 0) ? (diff + 1) : '';
                    }
                    daysInput.value = days;
                }
            });
        }
        function checkAndWarnAllActivityDates() {
            var allActDateInputs = stretchDetails.querySelectorAll('input[data-kind="act-start-date"], input[data-kind="act-end-date"]');
            allActDateInputs.forEach(function(input) {
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                const aidx = parseInt(input.getAttribute('data-aidx') || '-1', 10);
                let warn = false;
                let warnMsg = '';
                let val = (input.value || '').trim();
                // Check for valid DD/MM/YYYY
                let validDate = /^\d{2}\/\d{2}\/\d{4}$/.test(val);
                let d = validDate ? ddmmyyyyToDate(val) : null;
                if (!validDate || !d) {
                    warn = true;
                    warnMsg = 'Invalid date format (DD/MM/YYYY required)';
                } else if (idx >= 0 && aidx >= 0 && segments[idx]) {
                    const seg = segments[idx];
                    const stretchStart = ddmmyyyyToDate(seg.planned_start_date);
                    const stretchEnd = ddmmyyyyToDate(seg.planned_end_date);
                    if (stretchStart && d.getTime() < stretchStart.getTime()) {
                        warn = true;
                        warnMsg = 'Date is before stretch start date (' + dateToDdmmyyyy(stretchStart) + ')';
                    }
                    if (stretchEnd && d.getTime() > stretchEnd.getTime()) {
                        warn = true;
                        warnMsg = 'Date is after stretch end date (' + dateToDdmmyyyy(stretchEnd) + ')';
                    }
                }
                if (warn) {
                    input.style.borderColor = '#d44545';
                    input.style.background = 'rgba(214,69,69,0.18)';
                    input.title = warnMsg;
                } else {
                    input.style.borderColor = '';
                    input.style.background = '';
                    input.title = '';
                }
            });
        }
        actDateInputs.forEach(function(input) {
            input.addEventListener('input', function(e) {
                syncStretchDatesFromTableToSegments();
                checkAndWarnAllActivityDates();
                updateActivityDays();
                // Lock activity date within stretch range
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                const aidx = parseInt(input.getAttribute('data-aidx') || '-1', 10);
                if (idx >= 0 && aidx >= 0 && segments[idx]) {
                    const seg = segments[idx];
                    const stretchStart = ddmmyyyyToDate(seg.planned_start_date);
                    const stretchEnd = ddmmyyyyToDate(seg.planned_end_date);
                    let val = String(input.value || '').trim();
                    let d = ddmmyyyyToDate(val);
                    if (d && stretchStart && d.getTime() < stretchStart.getTime()) {
                        input.value = dateToDdmmyyyy(stretchStart);
                        d = stretchStart;
                    }
                    if (d && stretchEnd && d.getTime() > stretchEnd.getTime()) {
                        input.value = dateToDdmmyyyy(stretchEnd);
                    }
                }
            });
            input.addEventListener('blur', function(e) {
                // Lock activity date within stretch range
                syncStretchDatesFromTableToSegments();
                const idx = parseInt(input.getAttribute('data-idx') || '-1', 10);
                const aidx = parseInt(input.getAttribute('data-aidx') || '-1', 10);
                if (idx >= 0 && aidx >= 0 && segments[idx]) {
                    const seg = segments[idx];
                    const stretchStart = ddmmyyyyToDate(seg.planned_start_date);
                    const stretchEnd = ddmmyyyyToDate(seg.planned_end_date);
                    let val = String(input.value || '').trim();
                    let d = ddmmyyyyToDate(val);
                    if (d && stretchStart && d.getTime() < stretchStart.getTime()) {
                        input.value = dateToDdmmyyyy(stretchStart);
                        d = stretchStart;
                    }
                    if (d && stretchEnd && d.getTime() > stretchEnd.getTime()) {
                        input.value = dateToDdmmyyyy(stretchEnd);
                    }
                }
                checkAndWarnAllActivityDates();
                updateActivityDays();
            });
        });
        // Initial warning state (after render)
        checkAndWarnAllActivityDates();
        // Initial update
        updateActivityDays();
        // Only for activity date fields: force auto-formatting and caret at end
        const addDateFormatter = (input) => {
            if (!input || input._dateFormatHandler) return;
            function formatDate(val) {
                let value = val.replace(/\D/g, '').slice(0, 8);
                let formatted = '';
                if (value.length > 0) {
                    formatted += value.substring(0, 2);
                }
                if (value.length > 2) {
                    formatted += '/' + value.substring(2, 4);
                }
                if (value.length > 4) {
                    formatted += '/' + value.substring(4, 8);
                }
                return formatted;
            }
            function enforceFormat(e) {
                let formatted = formatDate(input.value);
                input.value = formatted;
                // Always move caret to end for simplicity
                if (document.activeElement === input) {
                    input.setSelectionRange(formatted.length, formatted.length);
                }
            }
            input.addEventListener('input', enforceFormat);
            input.addEventListener('blur', enforceFormat);
            input.addEventListener('paste', function(e) {
                e.preventDefault();
                let paste = (e.clipboardData || window.clipboardData).getData('text');
                input.value = formatDate(paste);
                input.setSelectionRange(input.value.length, input.value.length);
            });
            input.setAttribute('maxlength', '10');
            input._dateFormatHandler = true;
        };
        actDateInputs.forEach(addDateFormatter);

        function handleInput(e){
                                    // --- Chainage/Length sync logic ---
                                    if(kind === 'chainage-start'){
                                        let val = String(t.value || '').trim();
                                        let match = val.match(/^(\d+)\+(\d{3})$/);
                                        if(match) {
                                            let km = parseInt(match[1], 10);
                                            let m = parseInt(match[2], 10);
                                            let newStart = km * 1000 + m;
                                            let newLen = segments[idx].end_m - newStart;
                                            if(newLen > 0) {
                                                segments[idx].start_m = newStart;
                                                segments[idx].length_m = newLen;
                                                // Update length input field
                                                const row = t.closest('tr');
                                                if(row) {
                                                    let lenInput = row.querySelector('input[data-kind="stretch-length"]');
                                                    if(lenInput) lenInput.value = newLen;
                                                }
                                                t.style.borderColor = '';
                                                t.title = '';
                                                // Also update previous stretch's end chainage if exists
                                                if(idx > 0) {
                                                    segments[idx-1].end_m = newStart;
                                                    // Update previous row's end chainage input
                                                    let prevRow = stretchList.querySelector(`input[data-kind="chainage-end"][data-idx="${idx-1}"]`);
                                                    if(prevRow) prevRow.value = chainageFromMeters(newStart);
                                                }
                                            } else {
                                                t.style.borderColor = '#d44545';
                                                t.title = 'Start chainage must be less than end chainage';
                                                return;
                                            }
                                        }
                                    }
                                    if(kind === 'chainage-end'){
                                        let val = String(t.value || '').trim();
                                        let match = val.match(/^(\d+)\+(\d{3})$/);
                                        if(match) {
                                            let km = parseInt(match[1], 10);
                                            let m = parseInt(match[2], 10);
                                            let newEnd = km * 1000 + m;
                                            let newLen = newEnd - segments[idx].start_m;
                                            if(newLen > 0) {
                                                segments[idx].end_m = newEnd;
                                                segments[idx].length_m = newLen;
                                                // Update length input field
                                                const row = t.closest('tr');
                                                if(row) {
                                                    let lenInput = row.querySelector('input[data-kind="stretch-length"]');
                                                    if(lenInput) lenInput.value = newLen;
                                                }
                                                t.style.borderColor = '';
                                                t.title = '';
                                                // Also update next stretch's start chainage if exists
                                                if(idx < segments.length-1) {
                                                    segments[idx+1].start_m = newEnd;
                                                    // Update next row's start chainage input
                                                    let nextRow = stretchList.querySelector(`input[data-kind="chainage-start"][data-idx="${idx+1}"]`);
                                                    if(nextRow) nextRow.value = chainageFromMeters(newEnd);
                                                }
                                            } else {
                                                t.style.borderColor = '#d44545';
                                                t.title = 'End chainage must be greater than start chainage';
                                                return;
                                            }
                                        }
                                    }
                                    if(kind === 'stretch-length'){
                                        const val = parseInt(String(t.value || '0'), 10) || 1;
                                        // When length is changed, update end chainage to match
                                        segments[idx].length_m = Math.max(1, val);
                                        segments[idx].end_m = segments[idx].start_m + segments[idx].length_m;
                                        // Update end chainage input field
                                        const row = t.closest('tr');
                                        if(row) {
                                            let endInput = row.querySelector('input[data-kind="chainage-end"]');
                                            if(endInput) endInput.value = chainageFromMeters(segments[idx].end_m);
                                        }
                                    }
                        // --- Chainage/Length sync logic ---
                        if(kind === 'chainage-start'){
                            let val = String(t.value || '').trim();
                            let match = val.match(/^(\d+)\+(\d{3})$/);
                            if(match) {
                                let km = parseInt(match[1], 10);
                                let m = parseInt(match[2], 10);
                                let newStart = km * 1000 + m;
                                let newLen = segments[idx].end_m - newStart;
                                if(newLen > 0) {
                                    segments[idx].start_m = newStart;
                                    segments[idx].length_m = newLen;
                                    // Update length input field
                                    const row = t.closest('tr');
                                    if(row) {
                                        let lenInput = row.querySelector('input[data-kind="stretch-length"]');
                                        if(lenInput) lenInput.value = newLen;
                                    }
                                    t.style.borderColor = '';
                                    t.title = '';
                                } else {
                                    t.style.borderColor = '#d44545';
                                    t.title = 'Start chainage must be less than end chainage';
                                    return;
                                }
                            }
                        }
                        if(kind === 'chainage-end'){
                            let val = String(t.value || '').trim();
                            let match = val.match(/^(\d+)\+(\d{3})$/);
                            if(match) {
                                let km = parseInt(match[1], 10);
                                let m = parseInt(match[2], 10);
                                let newEnd = km * 1000 + m;
                                let newLen = newEnd - segments[idx].start_m;
                                if(newLen > 0) {
                                    segments[idx].end_m = newEnd;
                                    segments[idx].length_m = newLen;
                                    // Update length input field
                                    const row = t.closest('tr');
                                    if(row) {
                                        let lenInput = row.querySelector('input[data-kind="stretch-length"]');
                                        if(lenInput) lenInput.value = newLen;
                                    }
                                    t.style.borderColor = '';
                                    t.title = '';
                                } else {
                                    t.style.borderColor = '#d44545';
                                    t.title = 'End chainage must be greater than start chainage';
                                    return;
                                }
                            }
                        }
                        if(kind === 'stretch-length'){
                            const val = parseInt(String(t.value || '0'), 10) || 1;
                            // When length is changed, update end chainage to match
                            segments[idx].length_m = Math.max(1, val);
                            segments[idx].end_m = segments[idx].start_m + segments[idx].length_m;
                            // Update end chainage input field
                            const row = t.closest('tr');
                            if(row) {
                                let endInput = row.querySelector('input[data-kind="chainage-end"]');
                                if(endInput) endInput.value = chainageFromMeters(segments[idx].end_m);
                            }
                        }
            const t = e.target;
            if(!t) return;
            const kind = t.getAttribute('data-kind');
            const idx = parseInt(t.getAttribute('data-idx') || '-1', 10);
            if(idx < 0 || idx >= segments.length) return;

            if(kind === 'stretch-name'){
                segments[idx].stretch_name = String(t.value || '').trim() || segments[idx].stretch_name;
            }
            if(kind === 'stretch-start'){
                segments[idx].planned_start_date = String(t.value || '').trim();
                segments[idx]._manual_start = true;
                const row = t.closest('tr');
                const picker = row ? row.querySelector('[data-kind="stretch-start-picker"]') : null;
                if(picker) picker.value = ddmmyyyyToIso(segments[idx].planned_start_date);
                syncActivitiesToStretch(segments[idx], true);
            }
            if(kind === 'stretch-end'){
                segments[idx].planned_end_date = String(t.value || '').trim();
                segments[idx]._manual_end = true;
                const row = t.closest('tr');
                const picker = row ? row.querySelector('[data-kind="stretch-end-picker"]') : null;
                if(picker) picker.value = ddmmyyyyToIso(segments[idx].planned_end_date);
                syncActivitiesToStretch(segments[idx], true);
            }
            if(kind === 'stretch-start-picker'){
                const dd = isoToDdmmyyyy(String(t.value || '').trim());
                segments[idx].planned_start_date = dd;
                segments[idx]._manual_start = true;
                const row = t.closest('tr');
                const textInput = row ? row.querySelector('[data-kind="stretch-start"]') : null;
                if(textInput) textInput.value = dd;
                syncActivitiesToStretch(segments[idx], true);
            }
            if(kind === 'stretch-end-picker'){
                const dd = isoToDdmmyyyy(String(t.value || '').trim());
                segments[idx].planned_end_date = dd;
                segments[idx]._manual_end = true;
                const row = t.closest('tr');
                const textInput = row ? row.querySelector('[data-kind="stretch-end"]') : null;
                if(textInput) textInput.value = dd;
                syncActivitiesToStretch(segments[idx], true);
            }
            if(kind === 'stretch-length'){
                const val = parseInt(String(t.value || '0'), 10) || 1;
                segments[idx].length_m = Math.max(1, val);
                normalizeSegmentsTotal();
                refreshStretchChainageUI();
                serializeSegments();
                return;
            }

            if(kind === 'stretch-width'){
                const val = parseFloat(String(t.value || '0')) || 0;
                segments[idx].width_m = val;
                serializeSegments();
                return;
            }
            if(kind === 'stretch-depth'){
                const val = parseFloat(String(t.value || '0')) || 0;
                segments[idx].depth_m = val;
                serializeSegments();
                return;
            }

            const aidx = parseInt(t.getAttribute('data-aidx') || '-1', 10);
            if(aidx >= 0 && segments[idx].activities && segments[idx].activities[aidx]){
                const a = segments[idx].activities[aidx];
                if(kind === 'act-name') a.name = String(t.value || '').trim();
                if(kind === 'act-start-date') {
                    a.planned_start_date = String(t.value || '').trim();
                    a._manual_dates = true;
                }
                if(kind === 'act-end-date') {
                    a.planned_end_date = String(t.value || '').trim();
                    a._manual_dates = true;
                }
                if(kind === 'act-start-time') a.start_time = String(t.value || '').trim();
                if(kind === 'act-end-time') a.end_time = String(t.value || '').trim();
            }

            const midx = parseInt(t.getAttribute('data-midx') || '-1', 10);
            // Material input handling removed as per request

            serializeSegments();
        }

        function handleClick(e){
            const t = e.target;
            if(!t) return;
            const kind = t.getAttribute('data-kind');
            const idx = parseInt(t.getAttribute('data-idx') || '-1', 10);
            if(idx < 0 || idx >= segments.length) return;

            if(kind === 'toggle-details'){
                segments[idx]._showDetails = !(segments[idx]._showDetails !== false);
                renderSegments();
                return;
            }

            if(kind === 'act-add'){
                if(!segments[idx].activities) segments[idx].activities = [];
                segments[idx].activities.push({
                    name: '',
                    include: true,
                    planned_start_date: segments[idx].planned_start_date || '',
                    planned_end_date: segments[idx].planned_end_date || '',
                    start_time: '',
                    end_time: '',
                    planned_duration_hours: null,
                });
                renderSegments();
                return;
            }

            if(kind === 'update-days'){
                // Update days fields for this stretch (idx) and sync to data model, then re-render
                var detail = document.querySelector('div[data-kind="details-body"][data-idx="' + idx + '"]');
                if (detail) {
                    var actList = detail.querySelector('div[data-kind="act-list"]');
                    if (actList) {
                        var rows = actList.querySelectorAll('div');
                        rows.forEach(function(row) {
                            var nameInput = row.querySelector('input[data-kind="act-name"]');
                            var startInput = row.querySelector('input[data-kind="act-start-date"]');
                            var endInput = row.querySelector('input[data-kind="act-end-date"]');
                            var daysInput = row.querySelector('input[data-kind="act-days"]');
                            var aidx = startInput ? parseInt(startInput.getAttribute('data-aidx') || '-1', 10) : -1;
                            if (startInput && endInput && daysInput && aidx >= 0) {
                                // Always update the data model from the DOM before recalculating
                                if (segments[idx] && segments[idx].activities && segments[idx].activities[aidx]) {
                                    if (nameInput) segments[idx].activities[aidx].name = String(nameInput.value || '').trim();
                                    segments[idx].activities[aidx].planned_start_date = String(startInput.value || '').trim();
                                    segments[idx].activities[aidx].planned_end_date = String(endInput.value || '').trim();
                                }
                            }
                        });
                    }
                }
                // Sort activities by start date
                if (segments[idx] && segments[idx].activities) {
                    segments[idx].activities.sort(function(a, b) {
                        var dateA = ddmmyyyyToDate(a.planned_start_date);
                        var dateB = ddmmyyyyToDate(b.planned_start_date);
                        if (!dateA || !dateB) return 0;
                        return dateA.getTime() - dateB.getTime();
                    });
                }
                serializeSegments();
                // Now re-render, which will recalculate days and show the latest values
                renderSegments();
                return;
            }

            if(kind === 'act-remove'){
                const aidx = parseInt(t.getAttribute('data-aidx') || '-1', 10);
                if(aidx >= 0 && segments[idx].activities && segments[idx].activities[aidx]){
                    segments[idx].activities.splice(aidx, 1);
                    renderSegments();
                }
                return;
            }

            // Material add/remove handling removed as per request
        }


        if(btnGenerate){
            btnGenerate.addEventListener('click', function(){
                syncTotalLength();
                generateSegments();
                renderSegments();
                // Switch button colors
                btnGenerate.classList.remove('btn-primary');
                btnGenerate.classList.add('btn-secondary');
                btnAlign.classList.remove('btn-secondary');
                btnAlign.classList.add('btn-primary');
            });
        }

        if(btnAlign){
            btnAlign.addEventListener('click', function(){
                if(!segments.length) return;
                syncStretchDatesFromDom();
                // Only align if there are at least 2 stretches
                for(let i=1;i<segments.length;i++){
                    const prev = segments[i-1];
                    const seg = segments[i];
                    // If user has set dates, skip
                    if(seg._manual_start && seg._manual_end) continue;
                    // Estimate duration based on length, width, depth (simple heuristic: 1 day per 100m*width*depth)
                    let len = parseFloat(seg.length_m || 0);
                    let width = parseFloat(seg.width_m || 1);
                    let depth = parseFloat(seg.depth_m || 1);
                    if(isNaN(len) || len<=0) len = 100;
                    if(isNaN(width) || width<=0) width = 1;
                    if(isNaN(depth) || depth<=0) depth = 1;
                    // Heuristic: 1 day per 100m*width*depth (minimum 1 day)
                    let days = Math.max(1, Math.round((len * width * depth) / 100));
                    // Start date = previous stretch's end date + 1 day
                    let prevEnd = prev.planned_end_date;
                    let startDate = prevEnd;
                    if(prevEnd && /^\d{2}\/\d{2}\/\d{4}$/.test(prevEnd)){
                        let [d,m,y] = prevEnd.split('/').map(Number);
                        let dt = new Date(y, m-1, d);
                        dt.setDate(dt.getDate() + 1);
                        startDate = dt.toLocaleDateString('en-GB').replace(/\//g,'/');
                    }
                    // End date = start date + days - 1
                    let endDate = startDate;
                    if(startDate && /^\d{2}\/\d{2}\/\d{4}$/.test(startDate)){
                        let [d,m,y] = startDate.split('/').map(Number);
                        let dt = new Date(y, m-1, d);
                        dt.setDate(dt.getDate() + days - 1);
                        endDate = dt.toLocaleDateString('en-GB').replace(/\//g,'/');
                    }
                    if (!seg._manual_start && !seg.planned_start_date) seg.planned_start_date = startDate;
                    if (!seg._manual_end && !seg.planned_end_date) seg.planned_end_date = endDate;
                    // Do NOT reset _manual_start/_manual_end here
                    // Copy activities structure from previous stretch (names only, but update dates)
                    seg.activities = (prev.activities || []).map(a => ({
                        name: a.name,
                        include: true,
                        planned_start_date: startDate,
                        planned_end_date: endDate,
                        start_time: a.start_time || '',
                        end_time: a.end_time || '',
                        planned_duration_hours: a.planned_duration_hours || null,
                    }));
                }
                renderSegments();
                // Switch button colors
                btnAlign.classList.remove('btn-primary');
                btnAlign.classList.add('btn-secondary');
                btnGenerate.classList.remove('btn-secondary');
                btnGenerate.classList.add('btn-primary');
            });
        }

        if(stretchBlock){
            stretchBlock.addEventListener('input', handleInput);
            stretchBlock.addEventListener('change', handleInput);
            // Use event delegation for click events so dynamically added buttons work
            stretchBlock.addEventListener('click', function(e) {
                handleClick(e);
            });
        }

        if(projectType){
            projectType.addEventListener('change', function(){
                showStretchBlock();
                toggleRoadFields();
                toggleConcreteBlock();
                loadRoadPresets();
            });
        }
        if(roadCategory){
            roadCategory.addEventListener('change', function(){
                toggleConcreteBlock();
                loadRoadPresets();
            });
        }
        if(roadEngineering){
            roadEngineering.addEventListener('change', function(){
                toggleConcreteBlock();
                loadRoadPresets();
            });
        }
        if(totalLenKm){
            totalLenKm.addEventListener('change', syncTotalLength);
            totalLenKm.addEventListener('input', syncTotalLength);
        }

        toggleRoadFields();
        showStretchBlock();
        toggleConcreteBlock();
        syncTimelineInputs();
        loadRoadPresets();
    })();
    </script>

</form>

<form id="createUserForm" method="post" action="/projects/create-user"></form>

</div>
